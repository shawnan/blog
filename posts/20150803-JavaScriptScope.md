---
title: JavaScript作用域笔记
tags: javascript
date: 2015/08/03 22:11:00
---

# JavaScript作用域 #
                  
JavaScript的语法和C/C++语言类似，但是作用域却和C/C++不同。作用域，简单来说就是变量与函数的可访问范围，JavaScript中的作用域有全局作用域和局部作用域两种。
<!--more-->
   
## 全局作用域 ##
   
全局作用域在整个JavaScript应用里面都可以访问到，具体有以下几种情况。   
1、最外层定义的函数和变量拥有全局作用域。例如：   
    
```javascript
	var globalMsg = "我是全局变量";
	function foo(){
	var localMsg = "我是局部变量";
		alert(globalMsg);//我是全局变量
		alert(localMsg);//我是局部变量
	}
	alert(globalMsg);//我是全局变量
	alert(localMsg);//错误，未定义，在函数内部定义的变量，函数外部访问不到。
```   

2、未使用var关键字定义直接赋值的变量。例如：

    function foo(){
		globalMsg = "我是全局变量";
	}
	alert(globalMsg);

3、所有window对象的属性。例如window.name、window.ScreenX、window.parent等等，并且全局变量也会成为window的属性。   
   
    globalMsg = "全局变量";
	alert(window.globalMsg);//全局变量
	window.global = 100;
	alert(global);//100
	global = 10;
	alert(window.global);//10 

## 局部作用域 ##
   
局部作用域，顾名思义，只在一定的代码片段内能够被访问。
	   
1、没有块级作用域   
虽然有局部作用域，但是JavaScript是没有块级作用域的，只要是属于同一个函数内声明的变量，它们的作用域都是相同的，即便是子函数中定义的变量。例如：

    var global = "全局变量";
    function foo(){
		var  i = 0;
		if(i === 0){
			var j = 0;
			for(var k = 0; k < 3; k++){
				alert(k);//0 1 2
			}
		}
		alert(k);//3  //for循环中声明的变量在for循环执行完毕后仍旧存在于循环外部的执行环境
		alert(j);//0		
	}
	// i j k 的作用域都是相同的，在整个foo函数体内都是全局的。
声明变量的时候，使用`var`声明的变量会自动被添加到最接近的执行环境中，在函数内部，最接近的环境就是函数的局部环境；如果没有使用`var`声明，该变量会自动被添加到全局环境中。  
2、在函数体内，局部变量的优先级是高于全局变量的     
3、函数中声明的变量在整个函数中都有定义    
函数中声明的变量在整个函数中都有定义，即便是这个变量未被初始化。
     
    var global = "全局变量";
    function foo(){
		alert(global);//undefined
		var global = "局部变量";
		alert(global);//局部变量
		function man(){ 
			global = "新局部变量"; //新局部变量
		}
		man();
		alert(global);
	}
	foo();
	// 首先是函数体内的局部变量会隐藏同名的全局变量，因而第一个alert(global)
	// 会弹出undefined，因为JavaScript函数是解析执行的，会先把var定义的变量和function的
    // 名先进行存储，所以遇到第一个alert(global)时，global变量是处于未初始化的状态。
    // 而函数中声明的变量在整个函数中都有定义，所以man函数被调用后，global的值变成了"新局部变量"

## JavaScript的作用域链 ##
   
在JavaScript中，执行环境是很重要的一个概念，执行环境定义了变量或函数有权访问的其他数据，决定了它们的各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但是解析器在处理数据时会在后台使用它。    
全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或者浏览器——时才被销毁）。     
每个函数都有自己的**执行环境**，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正式由这个方便的机制控制着。   
当代码在一个环境中执行时，会创建变量对象的一个**作用域链**。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其 **活动对象** 作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。   
标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程中作用域链的前端开始，然后逐级的向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）。
   
##### 延长作用域链 #####
   
因为有些语句可以在作用域的前端临时增加一个变量对象，该变量对象会在代码执行后被移除，这个过程就相当于是延长了作用域。下面两种语句会延长作用域链：  
1、try-catch语言的catch块：   
catch语句会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。  
2、with语句：   
with语句会将指定的对象添加到作用域链中。